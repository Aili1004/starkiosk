package com.snepo.givv.cardbrowser.view.core{	import com.snepo.givv.cardbrowser.errors.*;	import com.snepo.givv.cardbrowser.model.*;	import com.snepo.givv.cardbrowser.util.*;	import com.greensock.*;	import flash.display.*;	import flash.system.*;	import flash.events.*;	import flash.utils.*;	import flash.geom.*;	import flash.net.*;	public class ImageCache extends EventDispatcher	{		public static const IMAGE : String = "ImageCache.IMAGE";		public static const THUMB : String = "ImageCache.THUMB";		public static const ICON : String = "ImageCache.ICON";		/*protected*/ public static var instance : ImageCache;		protected static var _ready : Boolean = false;		public static function getInstance ( ) : ImageCache		{			instance ||= new ImageCache ( new Private() );			return instance;		}		public static function get ready ( ) : Boolean		{			return _ready;		}		protected var _icons : Dictionary = new Dictionary();		protected var _thumbs : Dictionary = new Dictionary();		protected var _images : Dictionary = new Dictionary();		protected var _thumbCount : int = 0;		protected var _imageCount : int = 0;		protected var _iconCount : int = 0;		protected var _iconsLoaded : Boolean = false;		protected var _thumbsLoaded : Boolean = false;		protected var _imagesLoaded : Boolean = false;		protected var imagesLoaded : int = 0;    	public function ImageCache( p : Private )		{			super ( this );			if ( p == null ) throw new SingletonError ( "ImageCache" );		}		public function getThumb ( key : String, scale : Number = 1 ) : BitmapData		{			return createCopy ( _thumbs[key], scale );		}		public function getIcon ( key : String, scale : Number = 1 ) : BitmapData		{			return createCopy ( _icons[key], scale );		}		public function getImage ( key : String, scale : Number = 1 ) : BitmapData		{			return createCopy ( _images[key], scale );		}		protected function createCopy ( loaderOrBD : *, scale : Number = 1 ) : BitmapData		{			if ( !loaderOrBD ) return new BitmapData ( 10, 10, false, 0xFF0000 );			var source : BitmapData;			if ( loaderOrBD is Loader )			{				try				{					source = ( loaderOrBD.content as Bitmap ).bitmapData;				}catch ( e : Error )				{					return new BitmapData ( 10, 10, false, 0xFFFF00 );				}			}else if ( loaderOrBD is BitmapData )			{				trace ( "Getting raw bd copy" );				source = loaderOrBD as BitmapData;			}else			{				return new BitmapData ( 10, 10, false, 0xFFFF00 );			}			var output : BitmapData = new BitmapData ( source.width * scale, source.height * scale, false, 0xFF0000 );			var matrix : Matrix = new Matrix();			if ( scale != 1 ) matrix.scale( scale, scale );			output.draw ( source, matrix, null, null, null, true );			return output;		}		public function add ( type : String, key : String, path : String ) : void		{			if ( ready )			{				Logger.log ( "Image cache is already prepared. ", Logger.ERROR );				return;			}			switch ( type )			{				case THUMB :				{					if ( !_thumbs [ key ] )					{						_thumbs [ key ] = path;						_thumbCount++;					}					break;				}				case IMAGE :				{					if ( !_images [ key ] )					{						_images [ key ] = path;						_imageCount++;					}					break;				}				case ICON :				{					if ( !_icons [ key ] )					{						_icons [ key ] = path;						_iconCount++;					}					break;				}			}		}		public function load ( ) : void		{			if ( !_thumbsLoaded ) loadThumbQueue();			if ( !_iconsLoaded ) loadIconQueue();			if ( !_imagesLoaded ) loadImageQueue();		}		protected function loadThumbQueue ( ) : void		{			Logger.log ( "\tLoading thumb queue... (" + _thumbCount + ")" );			for ( var key : String in _thumbs )			{				var loader : Loader = new Loader();					loader.contentLoaderInfo.addEventListener ( Event.COMPLETE, onImageLoaded );					loader.contentLoaderInfo.addEventListener ( IOErrorEvent.IO_ERROR, onImageError );					loader.load ( new URLRequest ( Model.DROPBOX_PATH + _thumbs[key] ) );				_thumbs [ key ] = loader;			}		}		protected function loadIconQueue ( ) : void		{			Logger.log ( "\tLoading icon queue... (" + _iconCount + ")" );			for ( var key : String in _icons )			{				var loader : Loader = new Loader();					loader.contentLoaderInfo.addEventListener ( Event.COMPLETE, onImageLoaded );					loader.contentLoaderInfo.addEventListener ( IOErrorEvent.IO_ERROR, onImageError );					loader.load ( new URLRequest ( Model.DROPBOX_PATH + _icons[key] ) );				_icons [ key ] = loader;			}		}		protected function loadImageQueue ( ) : void		{			Logger.log ( "\tLoading image queue... (" + _imageCount + ")" );			for ( var key : String in _images )			{				var loader : Loader = new Loader();					loader.contentLoaderInfo.addEventListener ( Event.COMPLETE, onImageLoaded );					loader.contentLoaderInfo.addEventListener ( IOErrorEvent.IO_ERROR, onImageError );					loader.load ( new URLRequest ( Model.DROPBOX_PATH + _images[key] ) );				_images [ key ] = loader;			}		}		protected function onImageLoaded ( evt : Event ) : void		{			imagesLoaded++;			checkComplete();		}		protected function onImageError ( evt : ErrorEvent ) : void		{			trace ( "Error loading image " + evt.text );			// TODO: Load a dummy image in place of just letting it slide			imagesLoaded++;			checkComplete();		}		protected function replaceLoadersWithBitmaps ( type : String ) : void		{			var dict : Dictionary;			if ( type == ICON ) dict = _icons;			if ( type == IMAGE ) dict = _images;			if ( type == THUMB ) dict = _thumbs;			if ( !dict )			{				trace ( "Invalid dict" );				return;			}			for ( var key : String in dict )			{				if ( !(dict[key] is Loader) ) continue;				var loader : Loader = dict[key];					loader.removeEventListener ( Event.COMPLETE, onImageLoaded );					loader.removeEventListener ( IOErrorEvent.IO_ERROR, onImageError );					if ( loader.content )					{						var bitmapData : BitmapData = ( loader.content as Bitmap ).bitmapData;						delete dict[key];						dict[key] = bitmapData;						loader.unload();						loader = null;					}			}		}		protected function checkComplete ( ) : void		{			if ( !ready && imagesLoaded >= _thumbCount+_iconCount+_imageCount )			{				var a : int = System.totalMemory;				Environment.forceGC();				var b : int = System.totalMemory;				var c : int = ( a - b );				trace ( ( c  / 1024 / 1024 ).toFixed( 2 ) + "MB gain" );				_ready = true;				TweenMax.delayedCall ( 1, notifyReady );			}		}		protected function notifyReady ( ) : void		{			dispatchEvent ( new Event ( Event.COMPLETE ) );		}	}}class Private{}